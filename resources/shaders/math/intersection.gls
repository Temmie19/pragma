#ifndef F_INTERSECTION_GLS
#define F_INTERSECTION_GLS

vec2 intersect_ray_aabb(vec3 origin,vec3 dir,vec3 abbMin,vec3 aabbMax)
{
  vec3 tMin = (abbMin -origin) /dir;
  vec3 tMax = (aabbMax -origin) /dir;
  vec3 t1 = min(tMin,tMax);
  vec3 t2 = max(tMin,tMax);
  float tNear = max(max(t1.x,t1.y),t1.z);
  float tFar = min(min(t2.x,t2.y),t2.z);
  return vec2(tNear,tFar);
}

// Source: https://tavianator.com/fast-branchless-raybounding-box-intersections-part-2-nans/
bool test_ray_aabb(vec3 origin,vec3 dirInv,vec3 aabbMin,vec3 aabbMax)
{
    double t1 = (aabbMin[0] - origin[0])*dirInv[0];
    double t2 = (aabbMax[0] - origin[0])*dirInv[0];
 
    double tmin = min(t1, t2);
    double tmax = max(t1, t2);
 
    for (int i = 1; i < 3; ++i) {
        t1 = (aabbMin[i] - origin[i])*dirInv[i];
        t2 = (aabbMax[i] - origin[i])*dirInv[i];
 
        tmin = max(tmin, min(t1, t2));
        tmax = min(tmax, max(t1, t2));
    }
 
    return tmax > max(tmin, 0.0);
}

// Source: https://www.shadertoy.com/view/MlGcDz
vec3 test_ray_tri(vec3 origin,vec3 dir,vec3 v0,vec3 v1,vec3 v2)
{
    vec3 v1v0 = v1 - v0;
    vec3 v2v0 = v2 - v0;
    vec3 rov0 = origin - v0;

#if 0
    // Cramer's rule for solcing p(t) = ro+t·rd = p(u,v) = vo + u·(v1-v0) + v·(v2-v1)
    float d = 1.0/determinant(mat3(v1v0, v2v0, -rd ));
    float u =   d*determinant(mat3(rov0, v2v0, -rd ));
    float v =   d*determinant(mat3(v1v0, rov0, -rd ));
    float t =   d*determinant(mat3(v1v0, v2v0, rov0));
#else
    // The four determinants above have lots of terms in common. Knowing the changing
    // the order of the columns/rows doesn't change the volume/determinant, and that
    // the volume is dot(cross(a,b,c)), we can precompute some common terms and reduce
    // it all to:
    vec3  n = cross( v1v0, v2v0 );

    // Back-face culling
	if (dot(dir, normalize(n)) > 0)
		return vec3(-1,0,0);

    vec3  q = cross( rov0, dir );
    float d = 1.0/dot( dir, n );
    float u = d*dot( -q, v2v0 );
    float v = d*dot(  q, v1v0 );
    float t = d*dot( -n, rov0 );
#endif    

    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;
    
    return vec3( t, u, v );
}

// Source: http://www.cs.virginia.edu/~gfx/Courses/2003/ImageSynthesis/papers/Acceleration/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf
bool intersect_ray_triangle(vec3 origin,vec3 dir,vec3 v0,vec3 v1,vec3 v2,out float t,out float u,out float v,bool cull)
{
	const float EPSILON = 0.000001;
	t = 0.0;
	u = 0.0;
	v = 0.0;
	vec3 edge1 = v1 -v0;
	vec3 edge2 = v2 -v0;
	vec3 pvec = cross(dir,edge2);

	float det = dot(edge1,pvec);

	if(cull == true)
	{
		if(det < EPSILON)
			return false;
		vec3 tvec = origin -v0;
		u = dot(tvec,pvec);
		if(u < 0.0 || u > det)
			return false;
		vec3 qvec = cross(tvec,edge1);
		v = dot(dir,qvec);
		if(v < 0.0 || (u +v) > det)
			return false;
		t = dot(edge2,qvec);
		float invDet = 1.0 /det;
		t *= invDet;
		u *= invDet;
		v *= invDet;
	}
	else
	{
		if(det > -EPSILON && det < EPSILON)
			return false;
		float invDet = 1.0 /det;
		vec3 tvec = origin -v0;
		u = dot(tvec,pvec) *invDet;
		if(u < 0.0 || u > 1.0)
			return false;
		vec3 qvec = cross(tvec,edge1);
		v = dot(dir,qvec) *invDet;
		if(v < 0.0 || (u +v) > 1.0)
			return false;
		t = dot(edge2,qvec) *invDet;
	}
	return true;
}

#endif
