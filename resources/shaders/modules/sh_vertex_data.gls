#ifndef F_SH_VERTEX_DATA_GLS
#define F_SH_VERTEX_DATA_GLS

#include "sh_export.gls"
#include "../lighting/sh_lighting.gls"
#include "sh_vertex_data_locations.gls"

#ifndef USE_TANGENT_SPACE
	#define USE_TANGENT_SPACE 1
#endif

#if USE_TANGENT_SPACE == 1
#if ENABLE_TANGENT_SPACE_NORMALS == 1
	struct TangentVertexData
	{
		//vec3 cam_dir_to_vert_ts; // Normalized direction from camera to vertex in tangent space

		vec3 vert_tangent;
		vec3 vert_bitangent;
	};
#endif
#endif

struct VertexData
{
	mat3 TBN;
	vec3 vert_pos_ws; // Vertex Position in world space
	//vec3 vert_pos_cs; // Vertex Position in camera space
	//vec4 vert_pos_ls[MAX_LIGHTS]; // Arrays in structs appear to be problematic, moved to 'LightData' (See sh_light_data.gls)

	vec3 vert_normal; // Vertex Normal
	vec3 vert_normal_cs; // Vertex Normal in camera space

	vec2 vert_uv; // Texture coordinates
	vec2 vert_uv_lightmap; // Texture coordinates for light map atlas

#if USE_TANGENT_SPACE == 1
#if ENABLE_TANGENT_SPACE_NORMALS == 1
	TangentVertexData tangentData;
#endif
#endif
};
layout(location = SHADER_VERTEX_DATA_LOCATION) EXPORT_VS VertexData
#ifdef GLS_FRAGMENT_SHADER
	fs_in
#else
	vs_out
#endif
;

#ifdef GLS_FRAGMENT_SHADER
#define VERTEX_DATA fs_in
#else
#define VERTEX_DATA vs_out
#endif

vec3 get_vertex_position_ws() {return VERTEX_DATA.vert_pos_ws;}
//vec3 get_vertex_position_cs() {return VERTEX_DATA.vert_pos_cs;}
vec3 get_vertex_normal() {return VERTEX_DATA.vert_normal;}
vec3 get_vertex_normal_cs() {return VERTEX_DATA.vert_normal_cs;}

#endif
